[
  {
    "objectID": "posts/chemdose-quiz/chemdose_quiz.html",
    "href": "posts/chemdose-quiz/chemdose_quiz.html",
    "title": "Interactive Dashboard",
    "section": "",
    "text": "```{ojs}\nimport { select } from \"https://cdn.jsdelivr.net/npm/@observablehq/inputs@0.12/+esm\";\nimport { Plot } from \"https://cdn.jsdelivr.net/npm/@observablehq/plot/+esm\";\n\n// Define the iris dataset\nconst iris = [\n  { \"Sepal Length\": 5.1, \"Sepal Width\": 3.5, \"Petal Length\": 1.4, \"Petal Width\": 0.2, \"Species\": \"setosa\" },\n  { \"Sepal Length\": 4.9, \"Sepal Width\": 3.0, \"Petal Length\": 1.4, \"Petal Width\": 0.2, \"Species\": \"setosa\" },\n  // Add more data points here...\n];\n\nviewof x = select([\"Sepal Length\", \"Sepal Width\", \"Petal Length\", \"Petal Width\"], { label: \"X Variable\" });\nviewof y = select([\"Sepal Length\", \"Sepal Width\", \"Petal Length\", \"Petal Width\"], { label: \"Y Variable\" });\n\nPlot.plot({\n  marks: [\n    Plot.dot(iris, { x: d =&gt; d[Sepal.Length], y: d =&gt; d[Petal.Length], fill: \"Species\" })\n  ]\n})\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 15, column 1)Unexpected token"
  },
  {
    "objectID": "posts/chemdose-quiz/chemdose_quiz.html#interactive-visualization",
    "href": "posts/chemdose-quiz/chemdose_quiz.html#interactive-visualization",
    "title": "Interactive Dashboard",
    "section": "",
    "text": "```{ojs}\nimport { select } from \"https://cdn.jsdelivr.net/npm/@observablehq/inputs@0.12/+esm\";\nimport { Plot } from \"https://cdn.jsdelivr.net/npm/@observablehq/plot/+esm\";\n\n// Define the iris dataset\nconst iris = [\n  { \"Sepal Length\": 5.1, \"Sepal Width\": 3.5, \"Petal Length\": 1.4, \"Petal Width\": 0.2, \"Species\": \"setosa\" },\n  { \"Sepal Length\": 4.9, \"Sepal Width\": 3.0, \"Petal Length\": 1.4, \"Petal Width\": 0.2, \"Species\": \"setosa\" },\n  // Add more data points here...\n];\n\nviewof x = select([\"Sepal Length\", \"Sepal Width\", \"Petal Length\", \"Petal Width\"], { label: \"X Variable\" });\nviewof y = select([\"Sepal Length\", \"Sepal Width\", \"Petal Length\", \"Petal Width\"], { label: \"Y Variable\" });\n\nPlot.plot({\n  marks: [\n    Plot.dot(iris, { x: d =&gt; d[Sepal.Length], y: d =&gt; d[Petal.Length], fill: \"Species\" })\n  ]\n})\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 15, column 1)Unexpected token"
  },
  {
    "objectID": "posts/intro-vignette/intro_post.html",
    "href": "posts/intro-vignette/intro_post.html",
    "title": "Introduction to tidywater",
    "section": "",
    "text": "The tidywater package can be installed like any other package on CRAN by simply running install.packages(\"tidywater\"). For more details on the package, please see our public GitHub repository  here.\nThis vignette can also be accessed in RStudio by running the following\nlibrary(tidywater)\n\nvignette(\"intro\", package = \"tidywater\")"
  },
  {
    "objectID": "posts/intro-vignette/intro_post.html#defining-a-water",
    "href": "posts/intro-vignette/intro_post.html#defining-a-water",
    "title": "Introduction to tidywater",
    "section": "Defining a water",
    "text": "Defining a water\nThe first step for any modelling project using tidywater is to define your starting water quality using the define_water function. This function allows you to input everything you know about your water (pH, alkalinity, temperature, etc.). It also standardizes units for subsequent modelling steps, calculates the carbonate balance from the alkalinity and pH (if provided), and estimates the ionic strength of the water from your inputs. The function then takes all this information and creates a unique object of class “water” (for more details, see  R’s S4 class).\nThe “water” class is the building block of tidywater and allows you to keep track of all the changes in your water through various water treatment processes in a tidy way. Think of the “water” class as a snapshot of everything that is known about a water at each step in a modelling process.\nWhy does tidywater depend on this special class instead of just using a data frame? The water class is a good way to standardize inputs and set up a data structure that would reduce user error. Funneling users through define_water reduces naming errors in downstream functions. It also ensures that all slots have the proper data class. For example, ph must always be a number, and treatment is always a character.\nTo start, let’s create a blank water class and call it empty_water.\n\nempty_water &lt;- define_water()\n\nWarning in define_water(): Missing value for pH. Carbonate balance will not be\ncalculated.\n\n\nWarning in define_water(): Missing value for alkalinity. Carbonate balance will\nnot be calculated.\n\n\nWarning in define_water(): Major ions missing and neither TDS or conductivity\nentered. Ideal conditions will be assumed. Ionic strength will be set to NA and\nactivity coefficients in future calculations will be set to 1.\n\n\nNotice that several warnings are generated about the water class. define_water will return warnings noting the assumptions and limitations of the water class depending on how much information you provided. For example, since we did not provide any information about the water’s pH or alkalinity, the carbonate balance cannot be calculated. Similarly, since we did not provide any information about major ions in the water, information about the water’s hardness and ionic strength are missing.\nEven so, we successfully created our first water class! You can view the first few slots that a water class can contain by printing empty_water. But there are slots for general parameters, carbon content, corrosivity indicators, major cations and anions, and disinfection byproducts (DBPs). Different functions within tidywater will allow you to model all these parameters and more.\n\nprint(empty_water)\n\npH (unitless):  NA \nTemperature (deg C):  25 \nAlkalinity (mg/L CaCO3):  NA \nUse summary functions or slot names to view other parameters.\n\n\nSo let’s add some things to this water that we already know. Let’s say we know pH, alkalinity, temperature, and the sodium concentration. We can define each of these parameters as arguments in define_water, which accepts pH (unitless), alkalinity in units of mg/L CaCO3, temperature in degrees C, and ions in mg/L (with the exception of bromide and manganese, reported as ug/L). The function also refers to all chemical compounds by their chemical symbol or formula. Let’s call the new water class my_water.\nNotice that the slots for ph, alk, temp,and na are now populated when we print out the resulting water. The sodium slot (na) is output in units of mol/L (M). We can also see that define_water automatically calculated the amount of carbonate (co3) and bicarbonate (hco3) in the water based on the alkalinity and pH.\n\nmy_water &lt;- define_water(ph = 7.5, alk = 100, temp = 20, na = 5)\nmy_water\n\npH (unitless):  7.5 \nTemperature (deg C):  20 \nAlkalinity (mg/L CaCO3):  100 \nUse summary functions or slot names to view other parameters.\n\n\nYou can easily summarize your water quality using the summarize_wq function, which takes a water class object and exports an easy-to-read table of the water quality into the console.\n\nsummarize_wq(my_water)\n\n\n\n\n\n\n\n\nGeneral water quality parameters\nResult\nUnits\n\n\n\n\npH\n7.5\n-\n\n\nTemp\n20.0\ndeg C\n\n\nAlkalinity\n100.0\nmg/L as CaCO3\n\n\nTotal_Hardness\nNA\nmg/L as CaCO3\n\n\nTDS\nNA\nmg/L\n\n\nConductivity\nNA\nuS/cm\n\n\nTOC\nNA\nmg/L\n\n\n\n\n\n\n\n\n\nThis is a great way to get started with tidywater for users who only need to model a single water quality. If you have a large data set with multiple water qualities that you want to model, though, this might sound tedious. It wouldn’t be possible to manually enter your pH, alkalinity, temperature, etc. for, let’s say, 5,000 rows. Instead, tidywater has helper functions to generate many water classes simultaneously from an imported data set. See the help_functions_blend vignette for large data processing (paste this in the console: vignette(\"help_functions_blend\", package = \"tidywater\"))."
  },
  {
    "objectID": "posts/intro-vignette/intro_post.html#plotting-and-balancing-ions",
    "href": "posts/intro-vignette/intro_post.html#plotting-and-balancing-ions",
    "title": "Introduction to tidywater",
    "section": "Plotting and balancing ions",
    "text": "Plotting and balancing ions\nBack to our single use case, you’ll notice one of the warnings alerts the user to missing cations and/or anions, and that you should use balance_ions to correct this. This is based on the electroneutrality principle which states that the charges of all the cations and anions in a water should add up to 0. If your water is missing any ions, it is likely that it isn’t balanced. This could cause the results of your model to be off.\nTo check, you can use the plot_ions function on our water object to see what the current ion balance looks like. You can see that cation and anion bars are not equal, so this is not very realistic.\n\nplot_ions(my_water)\n\nWarning: Removed 5 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n\n\nWarning: Removed 5 rows containing missing values or values outside the scale range\n(`geom_text()`).\n\n\nWarning: Removed 5 rows containing missing values or values outside the scale range\n(`geom_text_repel()`).\n\n\n\n\n\n\n\n\n\nTo correct this, the balance_ions function automatically adds in sodium, potassium, chloride, or sulfate until anions + cations = 0. Let’s see what happens to the ion plot when we use balance_ions to estimate the missing ion concentrations.\n\nbalanced_water &lt;- my_water %&gt;% balance_ions()\nplot_ions(balanced_water)\n\n\n\n\n\n\n\n\nGreat! balance_ions added potassium to my_water so it is now electrically neutral. To see how much potassium was added, you can use the “@” symbol with a water class object to access the slot you want, in this case, potassium.\n\nmy_water@k # We did not input any potassium in the original water\n\n[1] NA\n\nbalanced_water@k # The balanced water now contains 0.00178 M of potassium\n\n[1] 0.001780775"
  },
  {
    "objectID": "posts/intro-vignette/intro_post.html#converting-units",
    "href": "posts/intro-vignette/intro_post.html#converting-units",
    "title": "Introduction to tidywater",
    "section": "Converting units",
    "text": "Converting units\nThe potassium units are in M. What if you want to know what that is in mg/L? There are two ways to do this in tidywater. The easiest way is to use the summarize_wq function shown above, which converts the ion concentrations back to mg/L.\nAnother option is to use the convert_units function, which allows you to specify the chemical and the starting and ending units. In this case, we want to convert the potassium concentration in balanced_water from M to mg/L.\n\nconvert_units(value = balanced_water@k, formula = \"k\", startunit = \"M\", endunit = \"mg/L\")\n\n[1] 69.62529"
  },
  {
    "objectID": "posts/intro-vignette/intro_post.html#modelling-assumptions",
    "href": "posts/intro-vignette/intro_post.html#modelling-assumptions",
    "title": "Introduction to tidywater",
    "section": "Modelling assumptions",
    "text": "Modelling assumptions\nThere are a couple of assumptions that define_water makes to be able to set up the data for downstream tidywater functions. These include standard ratios for hardness and DOC.\n\nHardness\nFirst, when only you only know the total hardness of the water (tot_hard), calcium hardness (ca_hard) is assumed to be 65% of the total, which is about average for  U.S. drinking water. When only ca_hard is provided, tot_hard is assumed to be equal to calcium hardness/0.65. Magnesium hardness (mg_hard) is then calculated as total hardness - calcium hardness.\nLet’s look at this using define_water. We can use convert_units to get the output in standard units of hardness. By defining only the total hardness, we see that the water vector also contains estimates for calcium and magnesium.\n\n# Calculate hardness or calcium hardness\nhard_water &lt;- define_water(8, 20, 100, tot_hard = 150)\n\n# total hardness in mg/L CaCO3\nhard_water@tot_hard\n\n[1] 150\n\n# calcium hardness\nconvert_units(value = hard_water@ca, formula = \"ca\", startunit = \"M\", endunit = \"mg/L CaCO3\")\n\n[1] 97.5\n\n# magnesium hardness\nconvert_units(value = hard_water@mg, formula = \"mg\", startunit = \"M\", endunit = \"mg/L CaCO3\")\n\n[1] 52.5\n\n\n\n\nTotal and dissolved organic carbon\nTOC and DOC inputs operate similarly to hardness. TOC and DOC are important to know for modelling and predicting various water treatment processes. If you only know TOC, define_water applies a standard conversion to estimate DOC, and vice versa. If only toc is provided, doc is assumed to be 95% of the TOC. If only doc is provided, toc is assumed to be DOC/0.95. This ratio would generally be an acceptable estimate for most drinking water scenarios, but the amount of TOC that is dissolved in raw waters could vary widely. Westerhoff and Anning, 2000 reported a range of 10-100% dissolved TOC in 25 surface waters, so keep in mind that the standard conversion may not be right for your context.\n\n# Calculate TOC and DOC\ntoc_water &lt;- define_water(8, 20, 100, toc = 3)\ntoc_water@toc # mg/L\n\n[1] 3\n\ntoc_water@doc # mg/L\n\n[1] 2.85\n\ndoc_water &lt;- define_water(8, 20, 100, doc = 1.3)\ndoc_water@toc # mg/L\n\n[1] 1.368421\n\ndoc_water@doc # mg/L\n\n[1] 1.3\n\n\nOverall, tidywater helps you model scenarios with as little information as possible because we often don’t have all the data we would like, but the less you have to assume about your water, the better. It’s important to understand and list the assumptions you are making during any modelling effort.\nCheck out our other vignettes to learn more about tidywater’s functions for modelling softening, coagulation, DBP formation…. here ____."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sidestreams",
    "section": "",
    "text": "Built-in tidywater features you didn’t know you needed\n\n\nHow to apply tidywater’s helper functions to a data frame\n\n\n\nhelper functions\n\n\nblend_waters\n\n\n\n\n\n\n\n\n\nNov 19, 2024\n\n\nLibby McKenna\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Dashboard\n\n\n\n\n\n\n\n\n\n\n\nNov 19, 2024\n\n\nLibby McKenna\n\n\n\n\n\n\n\n\n\n\n\n\nThree ways to find out if your water is haunted…\n\n\n…by challenging organics\n\n\n\ntoc\n\n\ntreatment\n\n\n\n\n\n\n\n\n\nNov 18, 2024\n\n\nSierra Johnson\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to tidywater\n\n\nHow to implement package models in your analysis.\n\n\n\nintro\n\n\n\n\n\n\n\n\n\nNov 5, 2024\n\n\nLibby McKenna & Riley Mulhern\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "sources.html",
    "href": "sources.html",
    "title": "Sources",
    "section": "",
    "text": "Sidestreams and the tidywater package were made possible by the wonderful open-source tools created by the R community. We want to give credit where it’s due and continue to foster collaboration and innovation."
  },
  {
    "objectID": "sources.html#tidywater",
    "href": "sources.html#tidywater",
    "title": "Sources",
    "section": "Tidywater",
    "text": "Tidywater\nThe tidywater package depends on functions from existing R packages, including:\n\ndplyr\ntidyr\nknitr\nggplot2\nggrepel\nmagrittr\npurrr\nfurrr\nmethods\nrlang"
  },
  {
    "objectID": "sources.html#sidestreams",
    "href": "sources.html#sidestreams",
    "title": "Sources",
    "section": "Sidestreams",
    "text": "Sidestreams\nThis blog is built in Quarto and is deployed using GitHub pages. See our public repository  here. In addition to the packages listed above, the tidyverse package is used throughout the blog."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to Sidestreams, where the tidywater developers post tips and stories relating to the tidywater R package."
  },
  {
    "objectID": "about.html#what-is-tidywater",
    "href": "about.html#what-is-tidywater",
    "title": "About",
    "section": "What is tidywater?",
    "text": "What is tidywater?\nTidywater is a free, open source R package containing drinking water quality models. Tidywater is available on CRAN and can easily be installed in RStudio using install.packages(\"tidywater\"). All models are publicly available. For references on all models, please see the public GitHub repository  here."
  },
  {
    "objectID": "about.html#what-models-are-included",
    "href": "about.html#what-models-are-included",
    "title": "About",
    "section": "What models are included?",
    "text": "What models are included?\nHere are some models in version 0.6.2 and how to reference them in your code. Note, this does not include all functions and models in tidywater.\n\n\n\n\n\n\n\n\nModel\nTidywater Function\nWhat it models\n\n\n\n\nTerry biofiltration model\nbiofilter_toc\nDOC removal from biofiltration\n\n\nEdwards coagulation\nchemdose_toc\nDOC removal from coadulation\n\n\nWTP model DBP formation\nchemdose_dbp\nDBP formation based on applied chlorine dose\n\n\nCorrosion and scaling indices\ncalculate_corrosion\naggressiveness, Ryznar, Langelier Saturation, calcium carbonate precipitation potential, Larson Skold, chloride to sulfate mass ratio\n\n\nTheoretical lead solubility\ndissolve_pb\nDissolved lead in water"
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html",
    "href": "posts/helpers-blend-vignette/blend_vignette.html",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "",
    "text": "If you have a ton of water quality parameters already in a data frame format, it might be frustrating to manually type each of them into define_water. That’s where the tidywater helper functions come in handy. In this post, we’ll show you how to pipe a data frame into a tidywater function using a water blending analysis.\nThis post assumes a basic understanding of define_water and the S4 water class. See vignette(\"intro\", package = \"tidywater\") for more information."
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#blending-analysis-setup",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#blending-analysis-setup",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "Blending Analysis Setup",
    "text": "Blending Analysis Setup\nIn this analysis, a hypothetical drinking water utility sources their water from a river and a lake, both of which have high hardness. The operators are investigating whether blending up to 5 MGD from two groundwater wells will reduce the total hardness below 200 mg/L as CaCO3."
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#define_water_once",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#define_water_once",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "define_water_once",
    "text": "define_water_once\nFirst, let’s take a look at the available groundwater data from Well A and Well B. Notice the use of define_water_once.\n\n# Example of how to use a tidywater \"_once\" function to define multiple waters in a single data frame\ndata &lt;- tibble(\n  Well = c(\"A\", \"B\"),\n  ph = c(8, 9),\n  alk = c(100, 150),\n  temp = c(18, 19),\n  ca = c(5, 10),\n  cond = c(500, 900),\n  tds = c(300, 500),\n  na = c(100, 200),\n  k = c(0, 20),\n  cl = c(0, 30),\n  so4 = c(0, 0)\n) %&gt;%\n  define_water_once()\n\ndata\n\n  Well ph temp alk tds   cond tot_hard           kw      alk_eq          na\n1    A  8   18 100 300 468.75 19.21002 6.309573e-15 0.001998264 0.004349761\n2    B  9   19 150 500 781.25 38.42004 6.309573e-15 0.002997395 0.008699522\n            ca           mg            k           cl so4        hco3\n1 0.0001247567 0.0000671767 0.0000000000 0.0000000000   0 0.001974750\n2 0.0002495134 0.0001343534 0.0005115312 0.0008461907   0 0.002647881\n           co3 h2po4 hpo4 po4 ocl     h           oh tot_po4 tot_ocl tot_nh3\n1 1.144647e-05     0    0   0   0 1e-08 6.309573e-07       0       0       0\n2 1.716027e-04     0    0   0   0 1e-09 6.309573e-06       0       0       0\n      tot_co3     is nh4 applied_treatment        estimated\n1 0.002026005 0.0075   0           defined _tothard_mg_cond\n2 0.002824530 0.0125   0           defined _tothard_mg_cond\n\n\ndefine_water_once is the first helper function we’ll cover. This function does exactly what define_water does, but applies it to a data frame input. This means once your data has the proper column names, define_water_once can add the parameters to each water slot, calculate the carbonate balance (and other relevant calculations), and outputs all parameters in the water class as a data frame. Any function with the _once suffix in tidywater can be used in a piped code block. However, tidywater functions cannot be used directly downstream of these types of functions because the data is no longer in a water class format."
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#define_water_chain",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#define_water_chain",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "define_water_chain",
    "text": "define_water_chain\nSo what if you want to chain more tidywater functions together? In that case, you can use define_water_chain. This function takes a dataframe input, then outputs all parameters in a water class column. This is true for all tidywater functions with the _chain suffix. _chain functions are handy in a piped code block where you’ll need to use many tidywater functions, such as chemdose_ph, solvedose_alk, etc. Most tidywater functions have a _chain or _once option.\n\n# Read in data from Wells A and B\nraw_wells_water &lt;- tibble(\n  Well = c(\"A\", \"B\"),\n  ph = c(8, 9),\n  alk = c(100, 150),\n  temp = c(18, 19),\n  ca = c(5, 10),\n  cond = c(500, 900),\n  tds = c(300, 500),\n  na = c(100, 200),\n  k = c(0, 20),\n  cl = c(0, 30),\n  so4 = c(0, 0)\n) %&gt;%\n  define_water_chain() %&gt;%\n  balance_ions_chain()\n\nraw_wells_water\n\n                                           defined_water Well\n1 &lt;S4 class 'water' [package \"tidywater\"] with 63 slots&gt;    A\n2 &lt;S4 class 'water' [package \"tidywater\"] with 63 slots&gt;    B\n                                          balanced_water\n1 &lt;S4 class 'water' [package \"tidywater\"] with 63 slots&gt;\n2 &lt;S4 class 'water' [package \"tidywater\"] with 63 slots&gt;\n\n\nIt’s always a good idea to verify our code is working properly. To make sure that our data was balanced using balance_ions_chain, we can plot our water class using plot_ions. The below example shows how to index a water class column: dataframe$water_class_column[[row_number]]\n\n# Ion plot before balance_ions_chain was applied\nraw_wells_water$defined_water[[1]] %&gt;%\n  plot_ions()\n\n\n\n\n\n\n\n# Plot of balanced ions\nraw_wells_water$balanced_water[[1]] %&gt;%\n  plot_ions()\n\n\n\n\n\n\n\n\nLet’s continue with our blending analysis. We’re going to treat our two wells as a single groundwater source. Blending can be calculated as Well_A_ratio * Well_A concentration + Well_B_ratio * Well_B_concentration. This is fine for most parameters, but for pH and acid/base equilibrium species, blending is a little more complicated. Enter: blend_waters. This function blends waters as you’d expect, and does all the pH blending math for you. In the example below, we’re going to be blending inefficiently. But don’t worry, there will be a better blending example later."
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#blend_waters",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#blend_waters",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "blend_waters",
    "text": "blend_waters\nTo blend our two wells, we will blend row 1 of balanced_water with row 2 of balanced_water. This “vertical” blending is not efficient and will not be useful for large data frames. water objects cannot be pivoted, hence the row-to-row blending. In later examples, we will actually blend columns, which is more amenable to piped code chunks.\nThe balanced_water function takes 2 or more waters (must be of the water class), and corresponding ratios for each water.\n\n# Blend \"vertically\": blends the data in well A's row with that of well B's.\n# The pluck function from the purrr package is useful for indexing a water class column\n### First, index the water column using the name or number of the column (ie \"balanced_water\" or 3 (column number))\n### Next, index the row\n\nblended_wells_water &lt;- blend_waters(\n  waters = c(\n    pluck(raw_wells_water, \"balanced_water\", 1),\n    pluck(raw_wells_water, 3, 2)\n  ),\n  ratios = c(.5, .5)\n)\n# outputs a water class object.\nblended_wells_water\n\npH (unitless):  8.73 \nTemperature (deg C):  18.5 \nAlkalinity (mg/L CaCO3):  125 \nUse summary functions or slot names to view other parameters.\n\n\nWe will create a data frame of the blend scenarios we will be modeling, in this case, we are varying flow rates from the different sources.\n\n# Assume wells can contribute 2.5 MGD each\ngroundwater &lt;- tibble(Wells_flow = c(0, 2.5, 5))\n# Blending scenarios and the resulting source water ratios\nscenarios &lt;- tibble(\n  surface_flow = seq(1, 20, 1),\n  River_flow = c(seq(1, 10, 1), rep(10, 10)),\n  Lake_flow = c(rep(0, 10), seq(1, 10, 1)),\n  group = seq(1, 20, 1)\n) %&gt;%\n  cross_join(groundwater) %&gt;%\n  mutate(\n    total_flow = River_flow + Lake_flow + Wells_flow,\n    River_ratio = River_flow / total_flow,\n    Lake_ratio = Lake_flow / total_flow,\n    Wells_ratio = Wells_flow / total_flow\n  )\n\nTo finish blending our wells, we will transform the blended_wells water object into a data frame containing a water column. The river and lake sources don’t require any mixing. We’ll set up their raw data and balance the ions using define_water_chain to make a data frame with a water column. In balance_ions_chain, we are specifying the name of the output columns so we can use the different water sources later. Most of tidywater’s _chain functions have the option to name the output column. Defaults vary depending on the _chain function.\n\nWells_water &lt;- tibble(wells = c(blended_wells_water))\n\nRiver_water &lt;- tibble(\n  ph = 7, temp = 20, alk = 200, tds = 950, cond = 1400,\n  tot_hard = 300, na = 100, cl = 150, so4 = 200\n) %&gt;%\n  define_water_chain() %&gt;%\n  balance_ions_chain(output_water = \"river\") %&gt;%\n  select(-defined_water)\n\nLake_water &lt;- tibble(\n  ph = 7.5, temp = 19, alk = 180, tds = 900, cond = 1000,\n  tot_hard = 350, ca_hard = 250, na = 100, cl = 100, so4 = 150\n) %&gt;%\n  define_water_chain() %&gt;%\n  balance_ions_chain(output_water = \"lake\") %&gt;%\n  select(-defined_water)"
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#blend_waters_chain",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#blend_waters_chain",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "blend_waters_chain",
    "text": "blend_waters_chain\nNow that we have our 3 sources defined, balanced, and cleaned up, we can blend them. This next code chunk showcases the power of tidywater. We’ll use blend_waters_chain, the helper function for blend_waters. We already created water class columns above, so we’ll use those column names in the waters argument. The ratios for each water source were calculated in the scenarios data frame. We’ll pass the names of those ratio columns into the ratio argument. The ratios must always add up to 1, otherwise the function will not run.\n\nblend_water &lt;- scenarios %&gt;%\n  cross_join(Wells_water) %&gt;%\n  cross_join(River_water) %&gt;%\n  cross_join(Lake_water) %&gt;%\n  blend_waters_chain(\n    waters = c(\"wells\", \"river\", \"lake\"),\n    ratios = c(\"Wells_ratio\", \"River_ratio\", \"Lake_ratio\")\n  )"
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#pluck_water",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#pluck_water",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "pluck_water",
    "text": "pluck_water\nWith all three source waters blended for each tested scenario, we can pull out a parameter of interest. In this case, we’re investigating how much we can dilute the total hardness. This brings us to our final helper function for this vignette: pluck_water. This function uses purrr::pluck to create a new column for one selected parameter from a water class object. You can choose which water column to pluck from using the input_water argument. Next, select the parameter of interest (which must match the water slot’s name). Finally, the output column’s name will default to the name of the plucked parameter, but there is an option to name it yourself using the output_column argument. If you want to view all the parameters as separate columns, it is better to use a _once function instead of _chain (i.e., we could have used blend_water_once above).\n\nplotting_data &lt;- blend_water %&gt;%\n  pluck_water(input_water = \"blended_water\", \"tot_hard\") %&gt;%\n  # Flag scenarios for plotting\n  mutate(Flagged = case_when(blended_water_tot_hard &gt; 200 ~ \"FLAG: Hardness &gt; 200 mg/L CaCO3\", TRUE ~ \"Not Flagged\"))\n\n# Plot the results!\nggplot(plotting_data, aes(x = total_flow, y = blended_water_tot_hard, color = as.character(Wells_flow), shape = Flagged)) +\n  geom_point() +\n  scale_shape_manual(values = c(4, 16)) +\n  labs(\n    y = \"Hardness (mg/L as CaCO3)\", color = \"Contributions from new wells (MGD)\",\n    shape = \"Scenario Flags\", x = \"Total Plant Flow (MGD)\"\n  ) +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    legend.box = \"vertical\",\n    legend.margin = margin(-5, 0, 0, 0)\n  )"
  },
  {
    "objectID": "posts/helpers-blend-vignette/blend_vignette.html#speed-it-up",
    "href": "posts/helpers-blend-vignette/blend_vignette.html#speed-it-up",
    "title": "Built-in tidywater features you didn’t know you needed",
    "section": "Speed it up",
    "text": "Speed it up\nAs you use more tidywater helper functions with larger data sets, you’ll notice the code can take a few minutes to run. All helper functions use functions from the  furrr package. To reduce processing time, you can activate furrr’s parallel processing power by using plan() at the beginning of your script. plan() depends on what type of operating system you have, more info on that in the  Controlling How Futures are Resolved table.\n\n# For most operating systems, especially Windows, use this at the beginning of your script\n# We recommend revmoving the `workers` argument to use your computer's full power.\nplan(multisession, workers = 2)\n\n# rest of script\n\n# At the end of the script, here's an option to explicitly close the multisession processing\nplan(sequential)"
  },
  {
    "objectID": "posts/haunted-water/haunted.html",
    "href": "posts/haunted-water/haunted.html",
    "title": "Three ways to find out if your water is haunted…",
    "section": "",
    "text": "Total organic carbon (TOC) is a bulk measurement that indicates the amount of organic matter in a water. However, properties of organic matter can vary widely. You may have heard terms like “humic” or “fulvic” fractions to describe different types of TOC. There are several analytical methods that can help uncover different TOC properties, such as fluorescence or size fractionation. But for most water treatment plants, we’re concerned about two main questions: TOC removal and disinfection byproduct (DBP) formation. Using historical data directly can be challenging because there are many water quality and operational parameters that impact how well TOC is removed and how much DBPs will form. Luckily, we have empirical models that can help understand plant performance and correct for these factors.\nThis description assumes you already have a basic knowledge of tidywater. If you don’t know how to create a water or how to connect functions togethers, start with the “getting started” vignette.\nWe’ll start by looking at these functions for one condition. We’ll begin by defining a water that has all the parameters we need for modeling.\n\nstart_water &lt;- define_water(ph = 7.4, temp = 12, alk = 80, tds = 100,\n                          toc = 3, doc = 2.8, uv254 = .1, br = 50)\n\nsummarize_wq(start_water, params = c(\"general\"))\n\n\n\n\n\n\n\n\nGeneral water quality parameters\nResult\nUnits\n\n\n\n\npH\n7.40\n-\n\n\nTemp\n12.00\ndeg C\n\n\nAlkalinity\n80.00\nmg/L as CaCO3\n\n\nTotal_Hardness\nNA\nmg/L as CaCO3\n\n\nTDS\n100.00\nmg/L\n\n\nConductivity\n156.25\nuS/cm\n\n\nTOC\n3.00\nmg/L\n\n\n\n\n\n\n\n\n\nThe two functions we’ll be using today are:\n\nchemdose_toc, which predicts the TOC removal from coagulation using the Edwards (1997) model.\nchemdose_dbp, which predicts the DBP formation from disinfection using the Amy model.\n\nWe also use chemdose_ph to account for pH changes from chemical addition. Often, we don’t need this function when we’re dealing with historical data because we have real measured pH at different points in the treatment process.\n\ncoag_water &lt;- start_water %&gt;%\n  chemdose_ph(alum = 30) %&gt;%\n  chemdose_toc(alum = 30)\n\nfin_water &lt;- coag_water %&gt;%\n  chemdose_ph(naocl = 4) %&gt;%\n  chemdose_dbp(cl2 = 2, time = 2, treatment = \"coag\")\n\nWarning in chemdose_dbp(., cl2 = 2, time = 2, treatment = \"coag\"): Temperature\nis outside the model bounds of temp=20 Celsius for coagulated water.\n\n\nWarning in chemdose_dbp(., cl2 = 2, time = 2, treatment = \"coag\"): pH is\noutside the model bounds of pH = 7.5 for coagulated water\n\nprint(paste(\"Coag DOC =\", round(coag_water@doc, 1), \"mg/L\"))\n\n[1] \"Coag DOC = 2.1 mg/L\"\n\nprint(paste(\"TTHM =\", round(fin_water@tthm), \"ug/L\"))\n\n[1] \"TTHM = 18 ug/L\"\n\n\nSo we can get some model outputs, but how does this tell us anything about our water? For that, we need to look at our historical data. We created some example data, but for a real analysis, this is when you would need to do data read-in and cleanup.\nThis first question we want to answer (to know if our water is “haunted”) is: Is my TOC hard to remove? By answering this question, we can understand the applicability of these empirical models and whether additional treatment (such as pre-ozone) would help. To answer this question, we want to apply chemdose_toc to our historical data using the _chain family of functions. First, we’ll have to set up the columns, including a new UV column. Since we don’t have historical UV data, we can assume a SUVA and calculate UV.\nNote that we don’t use chemdose_ph in this case because we have the coagulation pH in our historical data. We’re also treating TOC and DOC as interchangable because they are usually close and DOC wasn’t measured.\n\ncolnames(hist_data)\n\n[1] \"raw_toc\"   \"fin_toc\"   \"coag_ph\"   \"fin_ph\"    \"cl2_dose\"  \"alum_dose\"\n[7] \"tthm\"     \n\ncoag_model &lt;- hist_data %&gt;%\n  # Creating new columns to feed into define_water_chain\n  mutate(doc = raw_toc,\n         ph = coag_ph,\n         alum = alum_dose) %&gt;%\n  mutate(suva_raw = 2,\n         uv254 = suva_raw / 100 * doc) %&gt;%\n  define_water_chain(\"precoag\") %&gt;%\n  chemdose_toc_chain(\"precoag\", \"coag\") %&gt;%\n  # Pull out parameters of interest\n  pluck_water(\"coag\", \"doc\")\n\nWarning: There were 36 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `precoag = furrr::future_pmap(., define_water)`.\nCaused by warning in `...furrr_fn()`:\n! Missing value for alkalinity. Carbonate balance will not be calculated.\nℹ Run `dplyr::last_dplyr_warnings()` to see the 35 remaining warnings.\n\n# Plot actual vs modeled coagulated DOC\n\nggplot(coag_model, aes(x = fin_toc, y = coag_doc)) +\n  geom_point() +\n  geom_abline() +\n  coord_cartesian(xlim = c(0, NA), ylim = c(0, NA)) +\n  theme_bw() +\n  labs(x = \"Actual TOC\", y = \"Modeled TOC\")\n\n\n\n\n\n\n\n\nIn a plot like this, anything above the 1:1 line means that the model is predicting “worse” removal than we are actually seeing and below the 1:1 line means that the model is predicting “better” removal. So if most of your data is below the line, your TOC is more recalcitrant to removal than the waters used to create the model - more “challenging” than a typical source water. If you are close to the line, you can use the model to get a pretty good prediction of coagulation performance.\nThe next question we want to ask is: Are there conditions that make my TOC easier or harder to remove?\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]